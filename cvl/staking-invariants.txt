
### high-level invariants ("natural language"-expressed)
	- One time NFT stake (once used no stake() again)
	- Staking an NFT locks the NFT for the staking period (by changing ownership)
	- Conservation of ownership (staked NFT is returned to the original owner after unstake())
	- Reward for staking is evenly distributed for all stakers, at all rounds
	- Deposits are accepted only from game contract
	- Only the owner can withdraw remainder

### fine-grained invariantes (implementation based):
	- actionCounter always increments
	- stake/unstake operations are only allowed for stake(),unstake(),stakeMany(),unstakeMany() methods
	- stake/usntake operations are only allowed to modify all the fields of stakeAction[] array element (struct StakeAction), they can't modify one or two fields, all three fields must be modified
	- 
	- StakeAction struct in stakeActions[] array stays zero for unstaked tokens and non-zero for staked tokens
	- numSakedNfts alwas equal to the number of active stake actions (stakeAction[] with non-unstaked token)

	- Out of all the methods available in StakingWallet CST, only stake()/stakeMany() methods can change values in  usedNfts[] array (meaning, can mark NFTs with 'used' status)
	- Out of all the methods available in StakingWallet CST , only stake() and stakeMany() methods can set usedNfts[tokenId] to 1 for a particular tokenId (meaning, the NFT was used)
	- NFT ownership is given to the contract on stake(), and returned back to original owner on unstake()
	- After unstake() the balance of the contract is decreased by the same amount as the increase of the balance of staker's account
	Pending invariants to implement
	- A pair of stake()-unstake() operations must produce a payout equal to balance of the contract - reminder

